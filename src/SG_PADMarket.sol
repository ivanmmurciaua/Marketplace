// SPDX-License-Identifier: MIT OR Apache-2.0
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

import "hardhat/console.sol";


interface IPADNFT{
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function getApproved(uint256 tokenId) external view returns (address operator);
}

contract SG_PADMarket is IERC721Receiver, Pausable, Ownable, ReentrancyGuard {
  using Counters for Counters.Counter;

  Counters.Counter private _itemIds;
  Counters.Counter private _itemsSold;

  address private PAD_ADDRESS;
  address private FEE_RECEIVER;
  uint8   private FEES = 5;

  mapping(uint64 => MarketCard) private idToMarketCard;

  struct MarketCard {
    uint64   itemId;
    uint64   tokenId;
    uint64   limit;
    address  seller;
    address  owner;
    address  buyer;
    uint256  price;
    bool     deleted;
  }

  modifier isOwner(uint64 tokenId){

    require(
      IPADNFT(PAD_ADDRESS).ownerOf(tokenId) == msg.sender, 
      "You are not the owner of the card"
    );

    require(
      IPADNFT(PAD_ADDRESS).getApproved(tokenId) == address(this),
      "You need to approve it"
    );

    _;
  }

  modifier isSeller(uint64 itemId){
    require(
      itemId > 0,
      "Please, use a valid item"
    );

    address seller = idToMarketCard[itemId].seller;
    require(
      seller == msg.sender,
      "Caller is not sender"
    );

    _;
  }

  event Received();

  event MarketCardCreated (
    uint64 indexed itemId,
    uint64 indexed tokenId,
    address         seller,
    address         buyer,
    uint256         price,
    uint            limit
  );

  event MarketCardSold (
    uint64 indexed itemId,
    uint64 indexed tokenId,
    address         seller,
    address         owner,
    uint256         price,
    uint            limit
  );

  event MarketCardChanged (
    uint64 indexed itemId,
    uint64 indexed tokenId,
    address         seller,
    address         buyer,
    uint256         price,
    uint            limit
  );

  event MarketCardDeleted (
    uint64 indexed itemId
  );

  event MarketCardReturned (
    uint64 indexed itemId,
    uint64 indexed tokenId,
    address         seller
  );

  constructor(address _NFTContract, address _feeReceiver, uint8 _fees) {
    _itemIds.increment();
    PAD_ADDRESS = _NFTContract;
    FEE_RECEIVER = _feeReceiver;
    FEES = _fees;
  }

  function createOffer(uint64 tokenId, uint256 price, uint64 limit, address _buyer) public isOwner(tokenId) nonReentrant whenNotPaused {
    require(price > 0, "Price must be at least 1 wei");
    require(limit > 0, "Limit timestamp must be greater than 0");

    uint64 itemId = uint64(_itemIds.current());
    _itemIds.increment();
    
    address buyer = (_buyer != address(0)) ? _buyer : address(0);

    idToMarketCard[itemId] =  MarketCard(
      itemId,
      tokenId,
      limit,
      payable(msg.sender),
      payable(address(0)),
      buyer,
      price,
      false
    );

    IPADNFT(PAD_ADDRESS).safeTransferFrom(msg.sender, address(this), tokenId);

    emit MarketCardCreated(
      itemId,
      tokenId,
      msg.sender,
      buyer,
      price,
      limit
    );

  }

  function sellOffer(uint64 itemId) public payable nonReentrant whenNotPaused {

    require(itemId > 0, "Please use a valid item");
    require(!idToMarketCard[itemId].deleted, "Retired offer");
    require(idToMarketCard[itemId].owner == address(0), "Card already bought");

    uint256 realPrice = idToMarketCard[itemId].price;
    
    require(msg.value > realPrice , "Overflow error generated by sending a price under the real price");
    
    uint256 fees = realPrice * (FEES) / 100;
    uint256 priceSent = msg.value - fees;

    require(priceSent == realPrice, "Please submit the asking price in order to complete the purchase");
    
    if(idToMarketCard[itemId].buyer != address(0)){
      require(idToMarketCard[itemId].buyer == msg.sender, "This card has a preferent buyer");
    }

    require(idToMarketCard[itemId].limit >= block.timestamp, "Offer expired");

    MarketCard storage token = idToMarketCard[itemId];

    payable(token.seller).transfer(priceSent);

    IPADNFT(PAD_ADDRESS).safeTransferFrom(address(this), msg.sender, token.tokenId);

    token.owner = payable(msg.sender);

    payable(FEE_RECEIVER).transfer(fees);

    _itemsSold.increment();

    emit MarketCardSold (
      itemId,
      token.tokenId,
      token.seller,
      token.buyer,
      token.price,
      token.limit
    );

  }

  function changeOffer(uint64 itemId, uint256 price, uint64 limit, address _buyer) public isSeller(itemId) nonReentrant whenNotPaused {
    require(price > 0, "Price must be at least 1 wei");
    require(limit > 0, "Limit timestamp must be greater than 0");
    
    MarketCard storage token = idToMarketCard[itemId];

    token.price = (token.price == price) ? token.price : price;
    token.limit = (token.limit == limit) ? token.limit : limit;
    token.buyer = (_buyer == address(0)) ? token.buyer : _buyer;

    emit MarketCardChanged (
      itemId,
      token.tokenId,
      token.seller,
      token.buyer,
      token.price,
      token.limit
    );
  }

  function retireOffer(uint64 itemId) public isSeller(itemId) nonReentrant whenNotPaused {
    idToMarketCard[itemId].deleted = true;
    emit MarketCardDeleted(
      itemId
    );
  }

  function reOffer(uint64 itemId) public isSeller(itemId) nonReentrant whenNotPaused {
    idToMarketCard[itemId].deleted = false;
  }

  function returnCard(uint64 itemId) public isSeller(itemId) nonReentrant whenNotPaused {
    uint64 tokenId = idToMarketCard[itemId].tokenId;
    address seller = idToMarketCard[itemId].seller;

    IPADNFT(PAD_ADDRESS).safeTransferFrom(address(this), seller, tokenId);
    idToMarketCard[itemId].tokenId = 0;
    idToMarketCard[itemId].itemId = 0;

    emit MarketCardReturned(
      itemId,
      tokenId,
      seller
    );
  }

  function getMarketCard(uint64 MarketCardId) public view returns (MarketCard memory) {
    return idToMarketCard[MarketCardId];
  }
  
  function fetchAllMarketCards() external view returns (uint64[] memory) {

    uint64 itemCount = uint64(_itemIds.current()) - 1;

    uint64 unsoldItemCount = itemCount - uint64(_itemsSold.current());
    uint64[] memory items = new uint64[](unsoldItemCount);
    uint64 c = 0;

    for (uint64 i = 1; i <= itemCount; i++) {
      // console.log("I ", i);
      if ( idToMarketCard[i].owner == address(0)      && 
          !idToMarketCard[i].deleted                  && 
           idToMarketCard[i].limit >= block.timestamp &&
           idToMarketCard[i].itemId != 0
          ) {
        items[c] = idToMarketCard[i].itemId;
        c++;
      }
    }
   
    return items;
  }

  function marketBalanceOf() external view returns (uint){
    uint64 totalItemCount = uint64(_itemIds.current()) - 1;
    uint64 myItemCount = 0;

    for (uint64 i = 1; i <= totalItemCount; i++) {
      if (idToMarketCard[i].owner == msg.sender && !idToMarketCard[i].deleted) {
        myItemCount++;
      }
    }

    return myItemCount;
  }

  function marketBalanceOf(address _user) external view returns (uint){
    uint64 totalItemCount = uint64(_itemIds.current()) - 1;
    uint64 myItemCount = 0;

    for (uint64 i = 1; i <= totalItemCount; i++) {
      if (idToMarketCard[i].owner == _user && !idToMarketCard[i].deleted) {
        myItemCount++;
      }
    }

    return myItemCount;
  }

  function fetchMyMarketCards() external view returns (MarketCard[] memory) {
    uint64 totalItemCount = uint64(_itemIds.current()) - 1;
    uint64 myItemCount = 0;

    for (uint64 i = 1; i <= totalItemCount; i++) {
      if (idToMarketCard[i].owner == msg.sender) {
        myItemCount++;
      }
    }

    MarketCard[] memory items = new MarketCard[](myItemCount);

    for (uint64 i = 1; i <= totalItemCount; i++) {
      if (idToMarketCard[i].owner == msg.sender) {
        MarketCard storage currentItem = idToMarketCard[i];
        items[i] = currentItem;
      }
    }
   
    return items;
  }

  function fetchUserMarketCards(address _userAddress) public view returns (MarketCard[] memory) {
    uint64 totalItemCount = uint64(_itemIds.current()) - 1;
    uint64 myItemCount = 0;

    for (uint64 i = 1; i <= totalItemCount; i++) {
      if (idToMarketCard[i].owner == _userAddress) {
        myItemCount++;
      }
    }

    //Structs needs to be fixed-size array, push method don't works on struct dynamic-arrays
    MarketCard[] memory items = new MarketCard[](myItemCount);

    for (uint64 i = 1; i <= totalItemCount; i++) {
      if (idToMarketCard[i].owner == _userAddress) {
        MarketCard storage currentItem = idToMarketCard[i];
        items[i] = currentItem;
      }
    }
   
    return items;
  }

  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external override returns(bytes4) {
      _operator;
      _from;
      _tokenId;
      _data;
      emit Received();
      return 0x150b7a02;
  }

  function pause() public onlyOwner whenNotPaused {	
      _pause();	
  }	
  
  function unpause() public onlyOwner whenPaused {	
      _unpause();	
  }

  function setFees(uint8 _fee) external whenNotPaused onlyOwner {
    FEES = _fee;
  }

  function getFees() external view returns(uint8){
    return FEES;
  }

  function setPADAddress(address _address) external whenNotPaused onlyOwner {
    PAD_ADDRESS = _address;
  }

  function getPADAddress() external view returns(address){
    return PAD_ADDRESS;
  }

  function setFeeReceiver(address _feeReceiver) external whenNotPaused onlyOwner {
    FEE_RECEIVER = _feeReceiver;
  }

  function getFeeReceiver() external view returns(address){
    return FEE_RECEIVER;
  }
}